(ns mongol-drafts.services.draft
  (:require
   ["package:sqflite/sqflite.dart" :as sqf]
   [mongol-drafts.services.sqlite :as sql]))

(defn create-draft [v]
  (let [^sqf/Database db (await (sql/initialize-db))
        id1 (await
             (.rawInsert db
                         "INSERT INTO drafts values (?)"
                         [v]))
        _ (await
           (.rawInsert db
                       "INSERT INTO draft_info (draft_id) values (?)"
                       [id1]))]
    id1))

(defn delete-draft [id]
  (let [^sqf/Database db (await (sql/initialize-db))]
    (await
     (.rawDelete db
                 "DELETE FROM drafts WHERE rowid = ?"
                 [id]))
    (await
     (.rawDelete db
                 "DELETE FROM draft_info WHERE draft_id = ?"
                 [id]))))


(defn update-draft [id content]
  (let [^sqf/Database db (await (sql/initialize-db))
        num (await (.rawUpdate db
                               "UPDATE drafts SET content = ? WHERE rowid = ?"
                               [content id]))]
    num))

(defn list-drafts [offset tag-in-ids tag-out-ids]
  (let [^sqf/Database db (await (sql/initialize-db))]
    (await 
     (.rawQuery
      db
      (str 
      "select a.*, b.content, b.rowid as id
       from draft_info a 
          left join drafts b on a.draft_id = b.rowid 
          where 1 = 1 " 
         (cond
           (and (empty? tag-in-ids)
                (empty? tag-out-ids))
           ""

           (and (not-empty tag-in-ids) (not-empty tag-out-ids))
           (str
            " and draft_id in 
             (select draft_id from draft_tags 
                where tag_id in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-in-ids)) ")")
            ")"
            " and draft_id not in 
             (select draft_id from draft_tags 
                where tag_id in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-out-ids)) ")")
            ")")

           (not-empty tag-in-ids)
           (str
            " and draft_id in 
             (select draft_id from draft_tags 
                where tag_id in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-in-ids)) ")")
            ")")

           (not-empty tag-out-ids)
           (str
            " and draft_id not in 
             (select draft_id from draft_tags 
                where tag_id in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-out-ids)) ")")
            ")")) "
       order by a.updated_at desc
       ;")))))

(defn last-draft []
  (let [^sqf/Database db (await (sql/initialize-db))]
    (await
     (.rawQuery
      db
      "select a.*, b.content, b.rowid as id 
       from draft_info a 
          left join drafts b on a.draft_id = b.rowid 
       order by a.draft_id desc
       limit 1
       ;"))))

(defn get-draft [id]
  (let [^sqf/Database db (await (sql/initialize-db))]
    (await
     (.rawQuery
      db
      "select a.*, b.content, b.rowid as id 
       from draft_info a 
          left join drafts b on a.draft_id = b.rowid 
       where b.rowid = ?
       order by a.draft_id desc
       limit 1
       ;"
      [id]))))

(defn query-drafts [word tag-in-ids tag-out-ids offset
                    flag status]
  (let [^sqf/Database db (await (sql/initialize-db))
        ;; Runtime error: unable to use function MATCH in the requested context
        ids (->> (.rawQuery db
                            "select rowid from drafts 
                               where drafts match ?"
                            [word])
                 await
                 (map #(get % "rowid")))
        ids-q (str "(" (clojure.string/join ", " (map #(str %) ids)) ")")]
    (if (empty? ids)
      []
      (await
       (.rawQuery
        db
        (str
         "select a.*, b.content 
         from draft_info a 
          left join drafts b on a.draft_id = b.rowid 
         where draft_id in " ids-q 
         (cond
           (and (empty? tag-in-ids)
                (empty? tag-out-ids))
           ""

           (and (not-empty tag-in-ids) (not-empty tag-out-ids))
           (str
            " and draft_id in 
             (select draft_id from draft_tags 
                where tag_id in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-in-ids)) ")")
            " and tag_id not in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-out-ids)) ")")
            ")")

           (not-empty tag-in-ids)
           (str
            " and draft_id in 
             (select draft_id from draft_tags 
                where tag_id in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-in-ids)) ")")
            ")")

           (not-empty tag-out-ids)
           (str
            " and draft_id in 
             (select draft_id from draft_tags 
                where tag_id not in "
            (str "(" (clojure.string/join ", " (map #(str %) tag-out-ids)) ")")
            ")"))
         
         (if (not-empty flag)
           (str " and flag = " flag))
         (if (not-empty status)
           (str " and status = " status))
         "
         order by a.updated_at desc
         ;"))))))
