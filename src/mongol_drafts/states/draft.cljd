(ns mongol-drafts.states.draft
  (:require
   ["package:flutter/material.dart" :as m]
   [mongol-drafts.services.draft :as draft-service]))

(defn set-current-draft [state draft]
  (swap! state assoc :draft draft))

(defn new-draft [state]
  (let [result (await (draft-service/last-draft))
        content (-> result first (get "content"))
        ^m/TextEditingController
        controller (:text-controller @state)]
    (cond
      (empty? content)
      (do
        (swap! state assoc :draft
               (into {} (-> result first)))
        (.clear controller))

      :else
      (let [id (await (draft-service/create-draft ""))
            result (-> (draft-service/last-draft) await first)]
        (swap! state assoc :draft (into {} result))
        (.clear controller)))))

(defn delete-draft [state id]
  (let [result (await (draft-service/delete-draft id))]
    (if (= 1 result)
      (let [new-drafts (->> (get-in @state [:drafts :contents])
                            (remove #(if (= get % "id") id)))]
        (swap! state assoc-in [:drafts :contents]
               new-drafts)))))

(defn update-draft [state id content]
  (let [result (await (draft-service/update-draft id content))
        draft (:draft @state)]
    (swap! state assoc-in [:draft "content"] content)))

(defn list-drafts [state]
  (let [num (-> @state :drafts :contents count)
        drafts (await (draft-service/list-drafts num))]
    (if (empty? drafts)
      (do
        (swap! state assoc-in [:drafts :is-end] true)
        (swap! state assoc-in [:drafts :contents] []))
      (do
        (swap! state assoc-in [:drafts :is-end] false)
        (swap! state assoc-in [:drafts :contents]
               (concat (get-in @state [:drafts :contents]) drafts))))))

(defn query-drafts [state q]
  (if (empty? q)
    (let [num (-> @state :draft :contents count)
          drafts (await (draft-service/list-drafts num))]
      (if (empty? drafts)
        (swap! state assoc-in [:drafts :is-end] true)
        (do
          (swap! state assoc-in [:drafts :is-end] false)
          (swap! state assoc-in [:drafts :contents]
                 (into [] drafts)))))
    (let [num (-> @state :draft :contents count)
          drafts (await (draft-service/query-drafts q num))]
      (if (empty? drafts)
        (swap! state assoc-in [:drafts :is-end] true)
        (do
          (swap! state assoc-in [:drafts :is-end] false)
          (swap! state assoc-in [:drafts :contents]
                 (into [] drafts)))))))

(defn clear-drafts [state]
  (swap! state assoc-in [:drafts :is-end] false)
  (swap! state assoc-in [:drafts :contents] []))

;;;;;
(defn focus-on-draft [state text-controller]
  (swap! state assoc :show-keyboard true)
  (when (true? (:tag-on-edit @state))
    (let [^m/TextEditingController controller (:text-controller @state)]
      (.clear controller))
    (swap! state assoc :tag-on-edit false))
  (swap! state assoc :text-controller text-controller))