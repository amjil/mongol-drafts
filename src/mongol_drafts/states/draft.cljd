(ns mongol-drafts.states.draft
  (:require
   ["package:flutter/material.dart" :as m]
   [mongol-drafts.services.draft :as draft-service]
   [mongol-drafts.states.history :as his-state]
   [mongol-drafts.states.tag :as tag-state]))

(defn set-current-draft [state id]
  (let [result (await (draft-service/get-draft id))
        ^m/TextEditingController
        controller (:text-controller @state)]
    ;; Set tictoe false to prevent when (set! (.-text controller) ....)
    ;; to fire :bg-watcher [text-controller]
    (swap! state assoc :tictoe true)
    (swap! state assoc :draft (into {} (-> result first)))
    (tag-state/get-draft-tags state)
    (set! (.-text controller) (get (:draft @state) "content"))))

(defn new-draft [state]
  (let [result (await (draft-service/last-draft))
        content (-> result first (get "content"))
        ^m/TextEditingController
        controller (:text-controller @state)]
    (cond
      (and (empty? content) (number? (-> result first (get "id"))))
      (do
        (swap! state assoc :draft
               (into {} (-> result last)))
        (if-not (empty? (.-text controller))
          (.clear controller)))

      :else
      (let [id (await (draft-service/create-draft ""))
            result (-> (draft-service/last-draft) await last)]
        (swap! state assoc :draft (into {} result))
        (.clear controller)))))

(defn delete-draft [state id]
  (let [result (await (draft-service/delete-draft id))]
    (if (= 1 result)
      (let [new-drafts (->> (get-in @state [:drafts :contents])
                            (remove #(if (= get % "id") id)))]
        (swap! state assoc-in [:drafts :contents]
               new-drafts)))))

(defn update-draft [state id content]
  (let [result (await (draft-service/update-draft id content))
        draft (:draft @state)]
    (swap! state assoc-in [:draft "content"] content)))

(defn list-drafts [state]
  (let [;num (-> @state :drafts :contents count)
        flag (:draft/flag @state)
        status (:draft/status @state)
        drafts (await (draft-service/list-drafts
                       num [] [] flag status))]
    (if (empty? drafts)
      (do
        (swap! state assoc-in [:drafts :is-end] true)
        (swap! state assoc-in [:drafts :contents] []))
      (do
        (swap! state assoc-in [:drafts :is-end] false)
        (swap! state assoc-in [:drafts :contents]
               (concat (get-in @state [:drafts :contents]) drafts))))))

(defn query-drafts [state q has-filter]
  ;; has-filter false query without the tag filters
  ;;            true is query with the tag filters 
  (if (empty? q)
    (let [;num (-> @state :draft :contents count)
          tag-in-ids (map #(get % "id") (:filter-tags @state))
          tag-out-ids (map #(get % "id") (:omitted-tags @state))
          flag (:draft/flag @state)
          status (:draft/status @state)
          drafts (await (draft-service/list-drafts
                         0
                         (if has-filter tag-in-ids [])
                         (if has-filter tag-out-ids [])
                         flag status))]
      (if (empty? drafts)
        (do
          (swap! state assoc-in [:drafts :is-end] true)
          (swap! state assoc-in [:drafts :contents] []))
        (do
          (swap! state assoc-in [:drafts :is-end] false)
          (swap! state assoc-in [:drafts :contents]
                 (into [] drafts)))))
    (let [;num (-> @state :draft :contents count)
          tag-in-ids (map #(get % "id") (:filter-tags @state))
          tag-out-ids (map #(get % "id") (:omitted-tags @state))
          flag (:draft/flag @state)
          status (:draft/status @state)
          drafts (await (draft-service/query-drafts
                         q
                         (if has-filter tag-in-ids [])
                         (if has-filter tag-out-ids [])
                         0 flag status))]
      (if (empty? drafts)
        (swap! state assoc-in [:drafts :is-end] true)
        (do
          (swap! state assoc-in [:drafts :is-end] false)
          (swap! state assoc-in [:drafts :contents]
                 (into [] drafts)))))))

(defn clear-drafts [state]
  (swap! state assoc-in [:drafts :is-end] false)
  (swap! state assoc-in [:drafts :contents] []))

;;;;;
(defn focus-on-draft [state text-controller]
  (swap! state assoc :show-keyboard true)
  (when (true? (:tag-on-edit @state))
    (let [^m/TextEditingController controller (:text-controller @state)]
      (.clear controller))
    (swap! state assoc :tag-on-edit false))
  (swap! state assoc :text-controller text-controller)
  (when-not (empty? (:candidates-list @state))
    (swap! state assoc :candidates-list [])))

(defn draft-editing-listener [state edit-text text-controller]
  (if (true? (:tictoe @state))
    ;; TextEditingController text changed
    ;; ----- Or The Open Other draft should't catch event.
    (do
      (dart:core/print "nothing")
      (swap! state assoc :tictoe false))
    ;; TextEditingController text & selection change
    (do
      (dart:core/print "something")
      (swap! state assoc :tictoe true)
      (when (and (some? edit-text) (not= (:editor/content @state) edit-text))
        (dart:core/print (str " content = " (:editor/content @state) " edit-text = " edit-text))
        (swap! state assoc :editor/content edit-text)
        (dart:core/print (str " end = " " his-flag = " (:history/flag @state)))

        (let [id (get (:draft @state) "id")]
          (when (and (not (empty? edit-text))
                     (true? (:history/flag @state)))
            (dart:core/print "history >>")
            (his-state/push-history state edit-text text-controller))
          (update-draft state id edit-text))
        ;; check this is redo/undo event
        (when (false? (:history/flag @state))
          (swap! state assoc :history/flag false))))))

(defn initial-states [controller]
  {:tag-viewable false
   :show-keyboard false
   :show-stacked-keyboard false
   :show-drawer-search false
   :show-sub-drawer-search false
   :show-search-diaglog false
   :tag-on-edit false
   :current-layout "mn"
   :tictoe true
   :text-controller controller})

(defn set-draft-status [state i]
  (condp = i
    ;; Query Inbox drafts
    0
    (do
      (swap! state assoc :draft/flag nil)
      (swap! state assoc :draft/status 0)
      (query-drafts state (:draft-search @state) true))

    ;; Query Flaged drafts
    1
    (do
      (swap! state assoc :draft/flag 1)
      (swap! state assoc :draft/status 0)
      (query-drafts state (:draft-search @state) true))

    ;; Query Archived drafts
    2
    (do
      (swap! state assoc :draft/flag nil)
      (swap! state assoc :draft/status 1)
      (query-drafts state (:draft-search @state) true))

    ;; Query All drafts
    ;; 3
    ;; (do
    ;;   (swap! state assoc :draft/flag nil)
    ;;   (swap! state assoc :draft/status nil)
    ;;   (query-drafts state (:draft-search @state) true))

    ;; Query Deleted drafts
    3
    (do
      (swap! state assoc :draft/flag nil)
      (swap! state assoc :draft/status -1)
      (query-drafts state (:draft-search @state) true))))

(defn update-draft-search [state text]
  (swap! state assoc :draft-search text)
  (query-drafts state (:draft-search @state) true))